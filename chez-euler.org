#+title: Chez Euler
#+author: jitwit
#+property: :session *scheme*
#+options: num:nil

This is a the test suite as well as some kind of documentation as well
as me learning about org mode.

* Tests

** load.scm

Self-explanatory.

#+begin_src scheme :exports code :session euler
(load "./load.scm")
#+end_src 

#+RESULTS:
: #<void>

** eratosthenes.scm

Currently, there is an implementation of Eratosthenes sieve, a
segmented primes sieve, and a totient sieve.

*** Prime Count

#+begin_src scheme :exports code :results value :session euler
(define (pi n)
  (length (primes n)))
#+end_src 

src_scheme[:exports code]{pi} should agree with the [[https://en.wikipedia.org/wiki/Prime-counting_function][chart]] at
wikipedia.

#+begin_src scheme :exports both :results value :session euler
(for-each (lambda (n pi-n)
	    (assert (= pi-n (pi (expt 10 n)))))
	  (iota 9)
	  '(0 4 25 168 1229 9592 78498 664579 5761455))
'ok
#+end_src 

#+RESULTS:
: ok

*** Segmented vs Eratosthenes

#+begin_src scheme :exports code :results value :session euler
(define (filtered-eratosthenes A B)
  (filter (lambda (prime) 
	    (>= prime A))
	  (primes B)))

#+end_src 

#+RESULTS:
: #<void>

If the primes outside of a range /A,B/ are filtered out,
src_scheme[:exports code]{(filtered-eratosthenes A B)} and
src_scheme[:exports code]{(primes-in-range A B)} should agree.

#+begin_src scheme :exports both :results value :session euler
(for-each (lambda (A B)
	    (assert (equal? (filtered-eratosthenes A B)
			    (primes-in-range A B))))
	  '(1 5 3 100 8000 10000 100000 12000 100)
	  '(100 10 2 0 9000 20000 100100 12100 11000))
'ok
#+end_src 

#+RESULTS:

Fails for case 100 to 11000...

*** Totients

After defining:

#+begin_src scheme :exports code :results value :session euler
(define (slowtient N)
  (length (filter (lambda (n) 
		    (= 1 (gcd n N)))
		  (iota N))))
#+end_src 

#+RESULTS:
: #<void>

we check the results of the totient sieve:

#+begin_src scheme :exports both :results value :session euler
(let* ((limit 2000)
       (V (totient-sieve limit)))
  (for-each (lambda (k)
	      (assert (= (slowtient k) (fxvector-ref V k))))
	    (iota limit))
  'ok)
#+end_src 

#+RESULTS:
: ok

** miller-rabin.scm

*** Prime?

Being a simple implementation of the [[https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test][Miller-Rabin primality test]],
using 40 trial rounds. We can confirm that 

#+begin_src scheme :exports code :results value :session euler
(define (slow-primes N)
  (filter prime? (iota N)))

#+end_src 

#+RESULTS:
: #<void>

agrees with eratosthenes:

#+begin_src scheme :exports both :results value :session euler
(for-each (lambda (N)
	    (assert (equal? (primes N) (slow-primes N))))
	  '(0 1 3 10 100 1000 10000 100000))
'ok
#+end_src 

#+RESULTS:
: ok

** euclid.scm

Testing ~ax+by=gcd~ can be done by comparing the output gcd with the
library gcd, and verifying /s*x+t*y = gcd(x,y)/. ~inverse-modulo~ by
seeing if /s*x = 1 (mod y)/:

#+begin_src scheme :exports both :results value :session euler
(for-each (lambda (x y)
	    (let-values (((s t d) (apply values (ax+by=gcd x y))))
	      (assert (and (= d (gcd x y))
			   (= d (+ (* s x) (* t y)))))))
	  '(1769 240 17 4 3 0 12)
	  '(551 46 12 2 8 1 0))

(for-each (lambda (x m)
	    (let ((y (inverse-modulo x m)))
	      (if y
		  (assert (= 1 (mod (* x y) m)))
		  (not (= 1 (gcd x m))))))
	  '(1 5 7 11 4)
	  '(12 12 12 12 12))
'ok
#+end_src 

#+RESULTS:
: ok

** pollard.scm

Factorize numbers large and small. For now I'll just randomly type out
a bunch of numbers and check that the product of ~factorize~ spits
back the input.

#+begin_src scheme :exports both :results value :session euler
(for-each (lambda (n)
	    (assert (= n (apply * (factorize n)))))
	  '(2 123 123123123123 25852 234987 128 123884756 128367453485765213 98374 123627436526418192370348545876))
'ok
#+end_src 

#+RESULTS:
: ok

* Project Euler examples

Find the sum of all the primes below two million.

** Problem 3

What is the largest prime factor of the number 600851475143 ?

#+begin_src scheme :exports both :session euler
(define (e:3 N)
  (apply max (factorize N)))

(e:3 600851475143)
#+end_src 

#+RESULTS:
: 6857

** Problem 10

#+begin_src scheme :exports code :session euler
(define (e:10 N)
  (apply + (primes N)))
#+end_src 

#+RESULTS:
: #<void>

#+begin_src scheme :exports results :session euler
(e:10 2000000)

#+end_src

#+RESULTS:
: 142913828922

#+begin_src scheme :exports code :session euler
(define (e:10 N)
  (apply + (primes N)))
#+end_src 

#+RESULTS:
: #<void>

** Problem 69

Find the value of n ≤ 1,000,000 for which n/φ(n) is a maximum.

#+begin_src scheme :exports both :session euler
(define (e:69 N)
  (let ((T (totient-sieve N)))
    (car
     (sort (lambda (x y)
	     (> (/ (+ x 0.) (fxvector-ref T x))
		(/ (+ y 0.) (fxvector-ref T y))))
	   (cdr (iota (1+ N)))))))

(e:69 1000000)
#+end_src 

#+RESULTS:
: 510510

Of course, a better way to solve this is by noticing that /n/φ(n)/ is
the product over /p|n/ of /p/p-1/. This will be biggest when the /p/
are small and distinct.

#+begin_src scheme :exports both :session euler
(define (better-e:69 N)
  (let loop ((ps (primes N)) (best 1))
    (let ((next (* (car ps) best)))
      (if (> next N)
	  best
	  (loop (cdr ps) next)))))

(better-e:69 1000000)

#+end_src

#+RESULTS:
: 510510




